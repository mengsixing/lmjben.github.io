<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kubernetes 使用总结 | yhlben的前端日志</title>
    <meta name="description" content="欢迎访问我的前端日志">
    <link rel="icon" href="/hero.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.954741de.css" as="style"><link rel="preload" href="/assets/js/app.72175baa.js" as="script"><link rel="preload" href="/assets/js/2.d3d8ab05.js" as="script"><link rel="preload" href="/assets/js/27.cb9502a7.js" as="script"><link rel="prefetch" href="/assets/js/10.635e71fd.js"><link rel="prefetch" href="/assets/js/11.993079e0.js"><link rel="prefetch" href="/assets/js/12.4de31027.js"><link rel="prefetch" href="/assets/js/13.2f7f290b.js"><link rel="prefetch" href="/assets/js/14.8d586dc1.js"><link rel="prefetch" href="/assets/js/15.6ae40d7c.js"><link rel="prefetch" href="/assets/js/16.0c05e11b.js"><link rel="prefetch" href="/assets/js/17.16fd2cbd.js"><link rel="prefetch" href="/assets/js/18.40407c08.js"><link rel="prefetch" href="/assets/js/19.7203b985.js"><link rel="prefetch" href="/assets/js/20.d56fde43.js"><link rel="prefetch" href="/assets/js/21.f1da17bd.js"><link rel="prefetch" href="/assets/js/22.9edccecb.js"><link rel="prefetch" href="/assets/js/23.bec67227.js"><link rel="prefetch" href="/assets/js/24.b73d453b.js"><link rel="prefetch" href="/assets/js/25.00947339.js"><link rel="prefetch" href="/assets/js/26.9fccdfc4.js"><link rel="prefetch" href="/assets/js/28.5190ed22.js"><link rel="prefetch" href="/assets/js/29.fd06cde8.js"><link rel="prefetch" href="/assets/js/3.306f8ec3.js"><link rel="prefetch" href="/assets/js/30.78166332.js"><link rel="prefetch" href="/assets/js/31.aedcbf41.js"><link rel="prefetch" href="/assets/js/32.45c60a7a.js"><link rel="prefetch" href="/assets/js/33.f8574a11.js"><link rel="prefetch" href="/assets/js/34.664cf332.js"><link rel="prefetch" href="/assets/js/35.c0b16b63.js"><link rel="prefetch" href="/assets/js/36.85365675.js"><link rel="prefetch" href="/assets/js/37.442df408.js"><link rel="prefetch" href="/assets/js/38.5f64097c.js"><link rel="prefetch" href="/assets/js/39.8d3cfa64.js"><link rel="prefetch" href="/assets/js/4.d85e9879.js"><link rel="prefetch" href="/assets/js/40.3af1f878.js"><link rel="prefetch" href="/assets/js/41.10381927.js"><link rel="prefetch" href="/assets/js/42.32f41a30.js"><link rel="prefetch" href="/assets/js/43.b424c929.js"><link rel="prefetch" href="/assets/js/44.1449cb98.js"><link rel="prefetch" href="/assets/js/45.4b385709.js"><link rel="prefetch" href="/assets/js/46.86cfe922.js"><link rel="prefetch" href="/assets/js/47.a6e3de4b.js"><link rel="prefetch" href="/assets/js/48.79fb02d7.js"><link rel="prefetch" href="/assets/js/49.59601f37.js"><link rel="prefetch" href="/assets/js/5.e4ec2b8a.js"><link rel="prefetch" href="/assets/js/50.f89e27ce.js"><link rel="prefetch" href="/assets/js/51.32465e7e.js"><link rel="prefetch" href="/assets/js/52.b7bcce32.js"><link rel="prefetch" href="/assets/js/53.40ff5039.js"><link rel="prefetch" href="/assets/js/54.ee8f00d2.js"><link rel="prefetch" href="/assets/js/55.76221e8b.js"><link rel="prefetch" href="/assets/js/56.2255f189.js"><link rel="prefetch" href="/assets/js/57.0e437055.js"><link rel="prefetch" href="/assets/js/58.ae0f48a9.js"><link rel="prefetch" href="/assets/js/59.4f3f63bd.js"><link rel="prefetch" href="/assets/js/6.222582f7.js"><link rel="prefetch" href="/assets/js/60.42ace9a0.js"><link rel="prefetch" href="/assets/js/61.c064249c.js"><link rel="prefetch" href="/assets/js/62.b3a5600c.js"><link rel="prefetch" href="/assets/js/63.f3487ea0.js"><link rel="prefetch" href="/assets/js/64.c92baa21.js"><link rel="prefetch" href="/assets/js/65.158d00bc.js"><link rel="prefetch" href="/assets/js/66.2cc22f24.js"><link rel="prefetch" href="/assets/js/67.20898f1e.js"><link rel="prefetch" href="/assets/js/68.bfe2fe7f.js"><link rel="prefetch" href="/assets/js/69.6b374e5b.js"><link rel="prefetch" href="/assets/js/7.c5b1853c.js"><link rel="prefetch" href="/assets/js/70.3ce6233d.js"><link rel="prefetch" href="/assets/js/71.4dff83d4.js"><link rel="prefetch" href="/assets/js/72.3965e0c7.js"><link rel="prefetch" href="/assets/js/73.1ce4e3a7.js"><link rel="prefetch" href="/assets/js/74.739682b6.js"><link rel="prefetch" href="/assets/js/75.1e638873.js"><link rel="prefetch" href="/assets/js/76.fb3488d9.js"><link rel="prefetch" href="/assets/js/77.23e05221.js"><link rel="prefetch" href="/assets/js/78.7f1854fa.js"><link rel="prefetch" href="/assets/js/79.9bdadf0d.js"><link rel="prefetch" href="/assets/js/8.0edd772c.js"><link rel="prefetch" href="/assets/js/80.81bf5c77.js"><link rel="prefetch" href="/assets/js/81.c739a3aa.js"><link rel="prefetch" href="/assets/js/82.0db27d47.js"><link rel="prefetch" href="/assets/js/83.d77312b4.js"><link rel="prefetch" href="/assets/js/84.2aed7878.js"><link rel="prefetch" href="/assets/js/9.a0fe3ed8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.954741de.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">yhlben的前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link">阅读</a></div> <a href="https://github.com/yhlben/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/book/" class="nav-link">阅读</a></div> <a href="https://github.com/yhlben/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>DevOps</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops-kubernetes.html" class="active sidebar-link">Kubernetes 使用总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/devops-kubernetes.html#kubernetes-基础" class="sidebar-link">kubernetes 基础</a></li><li class="sidebar-sub-header"><a href="/blog/devops-kubernetes.html#kubernetes-优化" class="sidebar-link">Kubernetes 优化</a></li><li class="sidebar-sub-header"><a href="/blog/devops-kubernetes.html#kubernetes-实战" class="sidebar-link">Kubernetes 实战</a></li><li class="sidebar-sub-header"><a href="/blog/devops-kubernetes.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/blog/devops-docker.html" class="sidebar-link">Docker 使用总结</a></li><li><a href="/blog/devops-git.html" class="sidebar-link">Git 常用使用方式</a></li><li><a href="/blog/devops-dependencies.html" class="sidebar-link">Package.json 依赖管理</a></li><li><a href="/blog/devops-image.html" class="sidebar-link">合理选择图片格式</a></li><li><a href="/blog/devops-performance.html" class="sidebar-link">前端性能优化</a></li><li><a href="/blog/devops-commitlint.html" class="sidebar-link">Commitlint 使用总结</a></li><li><a href="/blog/devops-test.html" class="sidebar-link">前端测试</a></li><li><a href="/blog/devops-webpack-entry.html" class="sidebar-link">Webpack 系列（三）整体流程分析</a></li><li><a href="/blog/devops-webpack-flow.html" class="sidebar-link">Webpack 系列（二）手写模块打包代码</a></li><li><a href="/blog/devops-webpack.html" class="sidebar-link">Webpack 系列（一）使用总结</a></li><li><a href="/blog/devops-cdfang-spider.html" class="sidebar-link">实战：手搭一个 React，Typescript，Koa，GraphQL 环境</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/library-node.html" class="sidebar-link">Node.js 使用总结</a></li><li><a href="/blog/library-react.html" class="sidebar-link">React 使用总结</a></li><li><a href="/blog/libary-react-core.html" class="sidebar-link">React 核心知识</a></li><li><a href="/blog/library-react-ssr.html" class="sidebar-link">React 服务器端渲染</a></li><li><a href="/blog/library-react-hooks.html" class="sidebar-link">使用 React Hooks 节省 90% 的代码</a></li><li><a href="/blog/library-vue.html" class="sidebar-link">Vue 使用总结</a></li><li><a href="/blog/library-miniProgram.html" class="sidebar-link">小程序使用总结</a></li><li><a href="/blog/library-redux.html" class="sidebar-link">Redux 使用总结</a></li><li><a href="/blog/library-rxjs.html" class="sidebar-link">RxJS 基础知识总结</a></li><li><a href="/blog/libary-koa.html" class="sidebar-link">Koa 源代码阅读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/css.html" class="sidebar-link">CSS 使用总结</a></li><li><a href="/blog/css-next.html" class="sidebar-link">CSS NEXT 语法</a></li><li><a href="/blog/css-useful.html" class="sidebar-link">CSS 有趣的特性</a></li><li><a href="/blog/css-devicePixelRatio.html" class="sidebar-link">CSS 设备像素比</a></li><li><a href="/blog/css-houdini-star.html" class="sidebar-link">CSS Houdini 画一片星空</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络协议</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/osi-http.html" class="sidebar-link">HTTP 协议总结</a></li><li><a href="/blog/osi-https.html" class="sidebar-link">HTTPS 协议总结</a></li><li><a href="/blog/osi-web-security.html" class="sidebar-link">WEB 安全</a></li><li><a href="/blog/osi-web-login.html" class="sidebar-link">Web 登录鉴权</a></li><li><a href="/blog/osi-hijack.html" class="sidebar-link">流量劫持</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>运维相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/operation-docker-micro-service.html" class="sidebar-link">Docker 微服务小 Demo</a></li><li><a href="/blog/operation-linux.html" class="sidebar-link">Linux 快捷键</a></li><li><a href="/blog/operation-linux-login.html" class="sidebar-link">Linux 免密登录配置</a></li><li><a href="/blog/operation-nginx-load-balancing.html" class="sidebar-link">Nginx 负载均衡 Demo</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS 基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js-promise.html" class="sidebar-link">JS 理解 Promise</a></li><li><a href="/blog/js-this.html" class="sidebar-link">JS 理解 This</a></li><li><a href="/blog/js-operator-priority.html" class="sidebar-link">JS 运算符优先级</a></li><li><a href="/blog/js-jsBridge.html" class="sidebar-link">JS Bridge 总结</a></li><li><a href="/blog/js-module.html" class="sidebar-link">JS 模块化</a></li><li><a href="/blog/js-inherit.html" class="sidebar-link">JS 实现继承</a></li><li><a href="/blog/js-event.html" class="sidebar-link">JS 事件</a></li><li><a href="/blog/js-form.html" class="sidebar-link">JS 表单基础知识</a></li><li><a href="/blog/js-html5-program.html" class="sidebar-link">JS PostMessage &amp; 拖放 API</a></li><li><a href="/blog/js-recursion.html" class="sidebar-link">JS 函数尾递归优化</a></li><li><a href="/blog/js-object-ergodic.html" class="sidebar-link">JS 对象属性的遍历</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/base-functional.html" class="sidebar-link">函数式编程</a></li><li><a href="/blog/base-structure.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/blog/base-structure-base-select.html" class="sidebar-link">查找算法</a></li><li><a href="/blog/base-structure-base-sort.html" class="sidebar-link">基本排序算法</a></li><li><a href="/blog/base-structure-high-algorithm.html" class="sidebar-link">高级算法</a></li><li><a href="/blog/base-structure-senior-sort.html" class="sidebar-link">高级排序算法</a></li><li><a href="/blog/base-design-pattern.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>总结思考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/2019-6.html" class="sidebar-link">我的 2019 总结（上）</a></li><li><a href="/blog/2018.html" class="sidebar-link">我的 2018 总结</a></li><li><a href="/blog/frontend.html" class="sidebar-link">我的前端知识清单</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其它</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/other-tools.html" class="sidebar-link">常用工具整理</a></li><li><a href="/blog/other-vscode.html" class="sidebar-link">VSCode 常用快捷键</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="kubernetes-使用总结"><a href="#kubernetes-使用总结" aria-hidden="true" class="header-anchor">#</a> Kubernetes 使用总结</h1> <p>Kubernetes 简称 k8s，是 google 在 2014 年发布的一个开源项目。</p> <p>Kubernetes 解决了哪些问题？</p> <p>真实的生产环境应用会包含多个容器，而这些容器还很可能会跨越多个服务器主机部署。Kubernetes 提供了为那些工作负载大规模部署容器的编排与管理能力。Kubernetes 编排让你能够构建多容器的应用服务，在集群上调度或伸缩这些容器，以及管理它们随时间变化的健康状态。</p> <ul><li>kubernetes 基础</li> <li>kubernetes 优化</li> <li>kubernetes 实战</li></ul> <p>Kubernetes 基础概念很多，第一次接触容易看晕，如果是新手，建议直接看实战部分，先跑起来再说。</p> <h2 id="kubernetes-基础"><a href="#kubernetes-基础" aria-hidden="true" class="header-anchor">#</a> kubernetes 基础</h2> <p>k8s 中有几个重要概念。</p> <table><thead><tr><th>概念</th> <th>介绍</th></tr></thead> <tbody><tr><td>cluster</td> <td>一个 k8s 集群</td></tr> <tr><td>master</td> <td>集群中的一台机器，是集群的核心，负责整个集群的管理和控制</td></tr> <tr><td>node</td> <td>集群中的一台机器，是集群中的工作负载节点</td></tr> <tr><td>pod</td> <td>k8s 最小调度单位，每个 pod 包含一个或多个容器</td></tr> <tr><td>label</td> <td>一个 key = value 键值对，可以附加到各种资源对象上，方便其他资源进行匹配</td></tr> <tr><td>controller</td> <td>k8s 通过 controller 来管理 pod</td></tr> <tr><td>service</td> <td>对外提供统一的服务，自动将请求分发到正确的 pod 处</td></tr> <tr><td>namespace</td> <td>将 cluster 逻辑上划分成多个虚拟 cluster，每个 cluster 就是一个 namespace</td></tr></tbody></table> <h3 id="cluster"><a href="#cluster" aria-hidden="true" class="header-anchor">#</a> Cluster</h3> <p>Cluster 代表一个 k8s 集群，是计算、存储和网络资源的集合，k8s 利用这些资源运行各种基于容器的应用。</p> <h3 id="master-节点"><a href="#master-节点" aria-hidden="true" class="header-anchor">#</a> Master 节点</h3> <p>Master 是 cluster 的大脑，运行着的服务包括 kube-apiserver、kube-scheduler、kube-controller-manager、etcd 和 pod 网络。</p> <ul><li><strong>kube-apiserver</strong> <ul><li>apiserver 是 k8s cluster 的前端接口，提供 restful api。各种客户端工具以及 k8s 其他组件可以通过它管理 cluster 中的各种资源。</li></ul></li> <li><strong>kube-scheduler</strong> <ul><li>负责决定将 pod 放在哪个 node 上运行，scheduler 在调度时会充分考虑 cluster 中各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li></ul></li> <li><strong>kube-controller-manager</strong> <ul><li>负责管理 cluster 各种资源，保证资源处理预期状态。controller-manager 由多种 controller 组成，包括 replication controller，endpoint controller，namespace controller，serviceaccount controller 等。</li> <li>不同的 controller 管理不同的资源，例如：replication controller 管理 deployment ，statefulset，damonset 的生命周期，namespace controller 资源管理 namespace 资源。</li></ul></li> <li><strong>etcd</strong>（分布式 key-value 存储库）
<ul><li>负责保存 cluster 的配置信息和各种资源的状态信息。当数据发生变化时，etcd 会快速地通知 k8s 相关组件。</li></ul></li> <li><strong>pod 网络</strong> <ul><li>pod 要能够通信，cluster 必须部署 pod 网络，flannel 是其中一个可选方案。</li></ul></li></ul> <h3 id="node-节点"><a href="#node-节点" aria-hidden="true" class="header-anchor">#</a> Node 节点</h3> <p>Node 节点 是 pod 运行的地方。node 节点上运行的 k8s 组件有 kubelet、kube-proxy 和 pod 网络。</p> <ul><li><strong>kubelet</strong> <ul><li>kubelet 是 node 节点的代理，当 master 节点中 kube-scheduler 确定在某个 node 节点上运行 pod 后，会将 pod 的具体配置信息发送给该节点的 kubelet，kubelet 根据这些信息创建和运行容器，并向 master 节点报告运行状态。</li></ul></li> <li><strong>kube-proxy</strong> <ul><li>每个 node 节点都会运行 kube-proxy 服务，它负责将访问 service 的请求转发到后端的容器。如果有多个副本，kube-proxy 会实现负载均衡。</li></ul></li> <li><strong>pod 网络</strong> <ul><li>pod 要能够相互通信，k8s cluster 必须部署 pod 网络，flannel 是其中一个可选方案。</li></ul></li></ul> <h3 id="pod"><a href="#pod" aria-hidden="true" class="header-anchor">#</a> Pod</h3> <p>每一个 pod 包含一个或多个 container，pod 中的容器作为一个整体被 master 调度到 node 节点上运行。</p> <p>为什么 k8s 使用 pod 管理容器，而不是直接操作容器？</p> <p>1、因为有些容器天生就是需要紧密的联系，放在一个 pod 中表示一个完整的服务，k8s 同时会在每个 pod 中加入 pause 容器，来管理内部容器组的状态。</p> <p>2、Pod 中的所有容器共享 ip，共享 volume，方便进行容器之间通信和数据共享。</p> <div class="tip custom-block"><p class="custom-block-title">什么时候需要在 pod 中定义多个容器？</p> <p>答：这些容器联系非常紧密，而且需要直接共享资源，例如一个爬虫程序，和一个 web server 程序。web server 强烈依赖爬虫程序提供数据支持。</p></div> <h3 id="label"><a href="#label" aria-hidden="true" class="header-anchor">#</a> Label</h3> <p>Label 是一个 key = value 的键值对，其中 key 和 value 都由用户自己指定。</p> <p>Label 的使用场景：</p> <ul><li>kube-controller
<ul><li>通过 label selecter 筛选出要监控的 pod 副本，使 pod 副本数量符合预期。</li></ul></li> <li>kube-proxy
<ul><li>通过 label selecter 选择对应的 pod，自动建立每个 service 到对应 pod 的请求转发路由表，从而实现 service 的智能负载均衡机制。</li></ul></li> <li>通过对 node 定义 label，在 pod 中使用 node selector 匹配，kube-scheduler 进程可以实现 pod 定向调度的特性。</li></ul> <p>总之，label 可以给对象创建多组标签，label 和 label selecter 共同构建了 k8s 系统中核心的应用模型，使得被管理对象能够被精细地分组管理，同时实现了整个集群的高可用性。</p> <h3 id="controller"><a href="#controller" aria-hidden="true" class="header-anchor">#</a> Controller</h3> <p>k8s 通常不会直接创建 pod，而是通过 controller 来管理 pod。controller 中定义了 pod 的部署特性，比如有几个副本，在什么样的 node 上运行等。为了满足不同的业务场景，k8s 提供了多种类型的 controller。</p> <ul><li>Deployment
<ul><li>最常使用，可以管理 pod 多个副本，并确保 pod 按照期望的状态运行，底层调用 ReplicaSet。</li></ul></li> <li>ReplicaSet
<ul><li>实现 pod 的多副本管理，通常使用 Deployment 就够了。</li></ul></li> <li>DaemonSet
<ul><li>用于每个 node 最多只运行一个 pod 副本的场景。</li> <li>使用场景
<ul><li>在集群的每个节点上运行存储 Daemon，比如 glusterd 或 ceph。</li> <li>在每个节点上运行日志搜集 Daemon，比如 flunentd 或 logstash。</li> <li>在每个节点上运行监控，比如 Prometheus Node Exporter 或 collected。</li></ul></li></ul></li> <li>StatefuleSet
<ul><li>能够保证 pod 的每个副本在整个生命周期中名称是不变的，而其他 controller 不提供这个功能。</li></ul></li> <li>Job
<ul><li>用于运行结束就删除的应用，而其他 controller 中的 pod 通常是长期持续运行。</li></ul></li></ul> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>使用 deployment controller 创建的用例，如果出现有 pod 挂掉的情况，会自动新建一个 pod，来维持配置中的 pod 数量。</p></div> <h4 id="job"><a href="#job" aria-hidden="true" class="header-anchor">#</a> Job</h4> <p>容器按照持续运行时间可分为两类：服务类容器和工作类容器。</p> <p>服务类容器通常持续提供服务，需要一直运行，比如 http server。工作类容器则是一次性任务，比如批处理程序，完成后容器就退出。</p> <p>Controller 中 deployment、replicaSet 和 daemonSet 类型都用于管理服务类容器，对于工作类容器，我们使用 job。</p> <h3 id="service"><a href="#service" aria-hidden="true" class="header-anchor">#</a> Service</h3> <p>Service 是可以访问一组 pod 的策略，通常称为微服务。具体访问哪一组 pod 是通过 label 匹配出来的。service 为 pod 提供了负载均衡，原理是使用 iptables。</p> <p><strong>为什么要用 service ？</strong></p> <ul><li>pod 是有生命周期的，它们可以被创建，也可以被销毁，然而一旦被销毁生命就永远结束。而 pod 在一个 k8s 集群中可能经常性的创建，销毁，每一次重建都会产生一个新的 ip 地址。</li> <li>service 从逻辑上代表了一组 pod，具体是哪些 pod 是由 label 来挑选的。service 有自己的 ip，而且这个 ip 是不变的，客户端只需要访问 service 的 ip，k8s 则负责建立和维护 service 与 pod 的映射关系，无论 pod 如何变化，对客户端不会有任何影响，因为 service 没有变。</li></ul> <p><strong>外网如何访问 service？</strong></p> <ul><li>ClusterIP：通过集群的内部 ip 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 ServiceType。</li> <li>NodePort：通过每个 node 上的 ip 和端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 <code>nodeip:nodeport</code>，可以从集群的外部访问一个 service 服务。</li> <li>LoadBalancer：使用云提供商的负载局衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。</li> <li>ExternalName：通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容（例如， foo.bar.example.com）。 没有任何类型代理被创建，这只有 k8s 1.7 或更高版本的 kube-dns 才支持。</li></ul> <h3 id="namespace"><a href="#namespace" aria-hidden="true" class="header-anchor">#</a> Namespace</h3> <p>如果有多个用户使用同一个 k8s cluster，如何将他们创建的 controller，pod 等资源分开呢？</p> <p>答：使用 namespace。</p> <p>如果将物理的 cluster 逻辑上划分成多个虚拟 cluster，每个 cluster 就是一个 namespace，不同 namespace 里的资源是完全隔离的。</p> <p>k8s 默认创建了两个 namespace。</p> <ul><li>default 创建资源时如果不指定，将会放到这个 namespace 中。</li> <li>kube-system 存放 k8s 自己创建的系统资源。</li></ul> <h2 id="kubernetes-优化"><a href="#kubernetes-优化" aria-hidden="true" class="header-anchor">#</a> Kubernetes 优化</h2> <ul><li>健康检查</li> <li>数据管理</li> <li>密码管理</li> <li>集群监控</li></ul> <h3 id="健康检查"><a href="#健康检查" aria-hidden="true" class="header-anchor">#</a> 健康检查</h3> <p>强大的自愈能力是 k8s 这类容器编排引擎的一个重要特性。自愈的默认实现方式是自动重启发生故障的容器。除此之外，用户还可以利用 liveness 和 readiness 探测机制设置更精细的健康检查，进而实现如下需求：</p> <ul><li>零停机部署</li> <li>避免部署无效的镜像</li> <li>更加安全的滚动升级</li></ul> <p>默认情况下，只有容器进程返回值非零，k8s 才会认为容器发生了故障，需要重启。如果我们想更加细粒度的控制容器重启，可以使用 liveness 和 readiness。</p> <p>liveness 和 readiness 的原理是定期检查 <code>/tmp/healthy</code> 文件是否存在，如果存在即认为程序没有出故障，如果文件不存在，则会采取相应的措施来进行反馈。</p> <p>liveness 采取的策略是重启容器，而 readiness 采取的策略是将容器设置为不可用。</p> <div class="tip custom-block"><p>如果需要在特定情况下重启容器，可以使用 liveness。</p> <p>如果需要保证容器一直可以对外提供服务，可以使用 readiness。</p></div> <p>我们可以将 liveness 和 readiness 配合使用，使用 liveness 判断容器是否需要重启，用 readiness 判断容器是否已经准备好对外提供服务。</p> <h3 id="数据管理"><a href="#数据管理" aria-hidden="true" class="header-anchor">#</a> 数据管理</h3> <p>上文说道，pod 可能会被频繁地销毁和创建，当容器销毁时，保存在容器内部文件系统中的数据都会被清除。为了持久化保存容器的数据，可以使用 k8s volume。</p> <p>Volume 的生命周期独立于容器，pod 中的容器可能被销毁和重建，但 volume 会被保留。实质上 vloume 是一个目录，当 volume 被 mount 到 pod，pod 中的所有容器都可以访问到这个 volume。</p> <p>Volume 支持多种类型。</p> <ul><li>emptyDir
<ul><li>数据存放在 pod 中，对 pod 中的容器来说，是持久的，只要 pod 还在数据就还在。</li></ul></li> <li>hostPath
<ul><li>数据存在主机上，主机在数据就在。</li></ul></li> <li>AWS Elastic Block Store
<ul><li>数据存在云服务器上。</li></ul></li> <li>Persistent Volume
<ul><li>自定义一块外部存储空间 Persistent Volume，然后在创建 pod 时使用 PersistentVolumeClaim（PVC）去申请空间，并进行存储。</li></ul></li></ul> <p>Volume 提供了对各种类型的存放方式，但容器在使用 volume 读写数据时，不需要关心数据到底是存放在本地节点的系统中还是云硬盘上。对容器来说，所有类型的 volume 都只是一个目录。</p> <h3 id="密码管理"><a href="#密码管理" aria-hidden="true" class="header-anchor">#</a> 密码管理</h3> <p>应用程序在启动过程中可能需要一些敏感信息，比如访问数据库的用户名和密码。将这些信息直接保存在容器镜像中显然不妥，k8s 提供的解决方案是 secret。</p> <p>secret 会以密文的方式存储数据，避免直接在配置文件中保存敏感信息。secret 会以 volume 的形式被 mount 到 pod，容器可通过文件的方式使用 secret 中的敏感数据，此外容器也可以按环境变量的形式使用这些数据。</p> <p>使用配置文件创建 mysecret.yaml：</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
kind Secret
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  name<span class="token punctuation">:</span>mysecret
<span class="token key atrule">data</span><span class="token punctuation">:</span>
  username<span class="token punctuation">:</span>admin
  password<span class="token punctuation">:</span><span class="token number">123</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>保存配置文件后，然后执行<code>kubectl apply -f mysecret.yaml</code>进行创建。</p> <p>在 pod 中使用创建好的 secret：</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token comment"># mypod.yaml</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod
      <span class="token key atrule">image</span><span class="token punctuation">:</span> yhlben/notepad
  <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">'etc/foo'</span>
      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo
      <span class="token key atrule">secret</span><span class="token punctuation">:</span>
        <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>执行<code>kubectl apply -f mypod.yaml</code> 创建 pod，并使用 secret。创建完成后，secret 保存在容器内 /etc/foo/username ，/etc/foo/password 目录下。</p> <h3 id="集群监控"><a href="#集群监控" aria-hidden="true" class="header-anchor">#</a> 集群监控</h3> <p>创建 k8s 集群并部署容器化应用只是第一步。一旦集群运行起来，我们需要确保集群一切都是正常的，这就需要对集群进行监控。</p> <p>常用的可视化监控工具如下。</p> <ul><li>Weave Scope</li> <li>Heapster</li> <li>Prometheus Operator</li></ul> <p>具体的使用步骤就直接看文档了，这里不详细说明。</p> <p>通过集群监控我们能够及时发现集群出现的问题，但为了方便进一步排查问题，我们还需要进行进行日志记录。</p> <p>常用的日志管理工具如下。</p> <ul><li>Elasticsearch 负责存储日志并提供查询接口。</li> <li>Fluentd 负责从 k8s 搜集日志并发送给 Elasticsearch。</li> <li>Kibana 提供一个可视化页面，用户可以浏览和搜索日志。</li></ul> <h2 id="kubernetes-实战"><a href="#kubernetes-实战" aria-hidden="true" class="header-anchor">#</a> Kubernetes 实战</h2> <p>我们来实战部署一个 k8s 记事本项目，项目使用 <a href="https://cloud.docker.com/u/yhlben/repository/docker/yhlben/notepad" target="_blank" rel="noopener noreferrer">yhlben/notepad<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 镜像进行构建，该镜像在部署后会在 8083 端口上提供一个 web 版记事本服务，<a href="http://yinhengli.com:8083/" target="_blank" rel="noopener noreferrer">查看演示<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>为了避免安装 k8s 出现的各种坑，这里使用 <a href="https://labs.play-with-k8s.com/" target="_blank" rel="noopener noreferrer">Play with Kubernetes<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>进行演示。</p> <p>首先在 Play with Kubernetes 上创建 3 台服务器，node1 作为 master 节点，node2 和 node3 作为工作节点。接下来进行以下操作；</p> <ul><li>创建一个集群 cluster</li> <li>加入 node 节点</li> <li>初始化 cluster 网络</li> <li>创建 controller</li> <li>创建 service</li> <li>执行部署</li></ul> <h3 id="创建一个集群-cluster"><a href="#创建一个集群-cluster" aria-hidden="true" class="header-anchor">#</a> 创建一个集群 cluster</h3> <p>在 node1 上运行 kubeadm init 即可创建一个集群。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubeadm init --apiserver-advertise-address <span class="token variable"><span class="token variable">$(</span><span class="token function">hostname</span> -i<span class="token variable">)</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>执行完成后会生成 token，这样其他节点就可以凭借这个 token 加入该集群。</p> <p><img src="devops-kubernetes-step1.png" alt="Kubernetes 实战步骤1"></p> <h3 id="加入-node-节点"><a href="#加入-node-节点" aria-hidden="true" class="header-anchor">#</a> 加入 node 节点</h3> <p>在 node2 和 node3 机器上，分别执行以下命令，加入到 node1 的集群。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubeadm <span class="token function">join</span> 192.168.0.8:6443 --token nfs9d0.z7ibv3xokif1mnmv \
    --discovery-token-ca-cert-hash sha256:6587f474ae1543b38954b0e560832ff5b7c67f79e1d464e7f59e33b0fefd6548
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>命令执行完毕后，即可看到 node2，node3 已经加入成功。</p> <p><img src="devops-kubernetes-step2.png" alt="Kubernetes 实战步骤2"></p> <h3 id="查看集群状态"><a href="#查看集群状态" aria-hidden="true" class="header-anchor">#</a> 查看集群状态</h3> <p>在 node1 节点上，执行以下命令。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl get node
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="devops-kubernetes-step3.png" alt="Kubernetes 实战步骤3"></p> <p>可以看到，集群中存在 node1 ，node2，node3 这 3 个节点，但这 3 个节点的都是 NotReady 状态，为什么？</p> <p>答：因为没有创建集群网络。</p> <h3 id="创建集群网络"><a href="#创建集群网络" aria-hidden="true" class="header-anchor">#</a> 创建集群网络</h3> <p>执行以下代码创建集群网络。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl apply -n kube-system -f \
    <span class="token string">&quot;https://cloud.weave.works/k8s/net?k8s-version=<span class="token variable"><span class="token variable">$(</span>kubectl version <span class="token operator">|</span> base64 <span class="token operator">|</span><span class="token function">tr</span> -d <span class="token string">'\n'</span><span class="token variable">)</span></span>&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>执行命令后，稍等一下，然后查看 node 状态，可以看到，集群中的 3 个节点都是 Ready 状态了。</p> <p><img src="devops-kubernetes-step4.png" alt="Kubernetes 实战步骤4"></p> <h3 id="创建-deployment"><a href="#创建-deployment" aria-hidden="true" class="header-anchor">#</a> 创建 Deployment</h3> <p>我们通过配置文件来创建 deployment，新建 deployment.yaml 文件，内容如下：</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token comment"># 配置文件格式的版本</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1
<span class="token comment"># 创建的资源类型</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token comment"># 资源的元数据</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> notepad
<span class="token comment"># 规格说明</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token comment"># 定义 pod 数量</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token comment"># 通过 label 找到对应的 pod</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> mytest
  <span class="token comment"># 定义 pod 的模板</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token comment"># pod 的元数据</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token comment"># 定义 pod 的 label</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> mytest
    <span class="token comment"># 描述 pod 的规格</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> notepad
          <span class="token key atrule">image</span><span class="token punctuation">:</span> yhlben/notepad
          <span class="token key atrule">ports</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8083</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>文件创建之后，执行命令：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl apply -f ./deployment.yaml
<span class="token comment"># deployment.apps/notepad created</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>查看部署的 pod。</p> <p><img src="devops-kubernetes-step4.1.png" alt="Kubernetes 实战步骤4.1"></p> <p>可以看到，我们使用 deployment 类型的 controller 创建了 3 个 pod，分别运行在 node2 和 node3 机器上，如果有更多的机器，也会自动负载均衡，合理地分配到每个机器上。</p> <h3 id="创建-service"><a href="#创建-service" aria-hidden="true" class="header-anchor">#</a> 创建 Service</h3> <p>创建 service 和 deployment 类似，新建 service.yaml 文件，内容如下：</p> <div class="language-yml line-numbers-mode"><pre class="language-yml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token comment"># 在节点上部署访问 pod 的端口</span>
  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token comment"># service 代理的端口</span>
      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8083</span>
      <span class="token comment"># node 节点上提供给集群外部的访问端口</span>
      <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30036</span>
  <span class="token comment"># 匹配 pod</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> mytest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>文件创建之后，执行命令：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl apply -f ./service.yaml
<span class="token comment"># service/my-service created</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="查看创建结果"><a href="#查看创建结果" aria-hidden="true" class="header-anchor">#</a> 查看创建结果</h3> <p>使用 kubectl get deployment 和 kubectl get service 查看创建结果。</p> <p><img src="devops-kubernetes-step5.png" alt="Kubernetes 实战步骤5"></p> <p>可以看到，deployment 和 service 均创建成功，并且已知 service 暴露的 ip 地址为：10.106.74.65，端口号为 80，由于设置了 targetPort，service 在接收到请求时，会自动转发到 pod 对应的 8083 端口上。</p> <h3 id="访问部署结果"><a href="#访问部署结果" aria-hidden="true" class="header-anchor">#</a> 访问部署结果</h3> <p>部署成功后，我们可以通过两种方式进行访问：</p> <ul><li>集群内：通过 service 的 clusterIp + port 端口进行访问。</li> <li>集群外：通过任意一个 node 节点 + nodePort 端口进行访问。</li></ul> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 集群内访问</span>
<span class="token function">curl</span> 10.106.74.65
<span class="token comment"># 集群外访问</span>
<span class="token comment"># 192.168.0.12 是 node2 节点的ip</span>
<span class="token comment"># 192.168.0.11 是 node3 节点的ip</span>
<span class="token function">curl</span> 192.168.0.12:30036
<span class="token function">curl</span> 192.168.0.11:30036
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>集群内访问。</p> <p><img src="devops-kubernetes-step6.png" alt="Kubernetes 实战步骤6"></p> <p>集群外访问。</p> <p><img src="devops-kubernetes-step7.png" alt="Kubernetes 实战步骤6"></p> <p>到这里，已经算部署成功了，大家肯定有疑问，部署一个如此简单的 web 应用就这么麻烦，到底 k8s 好在哪里？我们接着往下看。</p> <h3 id="k8s-运维"><a href="#k8s-运维" aria-hidden="true" class="header-anchor">#</a> K8s 运维</h3> <p>项目已经部署，接下来来实战一个运维，感受一下 k8s 带给我们的便利。</p> <h4 id="案例-1"><a href="#案例-1" aria-hidden="true" class="header-anchor">#</a> 案例 1</h4> <p>公司要做双 11 活动，需要至少 100 个容器才能满足用户要求，应该怎么做？</p> <p>首先，应该尽可能利用当前拥有的服务器资源，创建更多的容器来参与负载均衡，通过 docker stats 可以查看容器占用的系统资源情况。如果充分利用后仍然不能满足需求，就根据剩余需要的容器，计算出需要购买多少机器，实现资源的合理利用。</p> <ul><li>购买服务器，将服务器作为 node 节点，join 到集群中。</li> <li>执行扩容命令。</li></ul> <p>执行以下命令就能将容器扩展到 100 个。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl scale deployments/notepad --replicas<span class="token operator">=</span>100
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如图，扩展 10 个 pod 的情况，node2 和 node3 节点共同分担负载。</p> <p><img src="devops-kubernetes-step8.png" alt="Kubernetes 实战步骤8"></p> <p>也可以通过修改 deployment.yaml 中的 replicas 字段，执行 <code>kubectl apply -f deployment.yaml</code>去执行扩展。如果活动结束了，只需要将多余的服务器删除，缩减容器数量即可还原到之前的效果。</p> <h4 id="案例-2"><a href="#案例-2" aria-hidden="true" class="header-anchor">#</a> 案例 2</h4> <p>双 11 活动很火爆，但突然加了需求，需要紧急上线，如果实现滚动更新？</p> <p>滚动更新就是在不宕机的情况下，实现代码更新。执行以下命令，修改 image 即可。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl <span class="token keyword">set</span> image deployments/notepad notepad<span class="token operator">=</span>yhlben/notepad:new
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也可以通过修改 deployment.yaml 中的 image 字段，执行 <code>kubectl apply -f deployment.yaml</code>去执行升级。</p> <p>如果更新出了问题，k8s 内置了一键还原上个版本的命令：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>kubectl rollout undo deployments/notepad
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过这 2 个案例，感觉到了 k8s 给运维带来了很大的便利：<strong>快速高效地部署项目</strong>，<strong>支持动态扩展</strong>、<strong>滚动升级</strong>，<strong>同时还能按需优化使用的硬件资源</strong>。</p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>本文的目的就是入门 k8s，通过一个简单的集群来实现这一点，但其中也踩了好多坑，具体如下：</p> <ul><li>使用 minikube 搭建项目
<ul><li>能快速搭建一个单节点 k8s 环境。</li> <li>但在本地使用 minikube 搭建一套 k8s 集群，很多包装不上，全局代理也不行。</li></ul></li> <li>使用 google clould 上的服务器
<ul><li>在 gogole clould 上，解决了网络问题，需要安装的包都能装上。</li> <li>但由于是新服务器，需要各种安装环境，docker，kubeadm，kubectl 等，安装过程繁琐，还可能会遇到报错。</li> <li>不知道哪天手滑了一下，试用账号变成了付费账号，赠金 $300 就这样没了 😭。</li></ul></li> <li>使用 play with kubernetes
<ul><li>k8s 所需环境不用配，已经装好了，这一点很不错。</li> <li>单台机器容量太小，稍微大一点的镜像就安装不进去了。</li> <li>偶尔使用 play with kubernetes 时，刚新建完一个实例，就被踢下线，遇到这种情况就没法玩。</li> <li>没有提供公网 ip，无法验证外网访问情况。</li></ul></li></ul> <p>最后，推荐一下《每天 5 分钟玩转 Kubernetes》这本书，一本非常适合入门 k8s 的实战书。书中通过大量的简单实战，从易到难，让我真正理解了 k8s，本文中的大量理论知识也都来自这本书。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/yhlben/blog/edit/master/docs/blog/devops-kubernetes.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新时间: </span> <span class="time">7/7/2019, 2:29:10 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/devops-docker.html">
          Docker 使用总结
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.72175baa.js" defer></script><script src="/assets/js/2.d3d8ab05.js" defer></script><script src="/assets/js/27.cb9502a7.js" defer></script>
  </body>
</html>
