<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文串联 HTTP、TCP、IP、以太网 | 前端日志</title>
    <meta name="description" content="欢迎访问公众号：前端日志">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/hero.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.7ffd56ab.css" as="style"><link rel="preload" href="/assets/js/app.d9edef80.js" as="script"><link rel="preload" href="/assets/js/2.735dd80d.js" as="script"><link rel="preload" href="/assets/js/92.65987233.js" as="script"><link rel="preload" href="/assets/js/3.782c6b4d.js" as="script"><link rel="prefetch" href="/assets/js/10.505689c0.js"><link rel="prefetch" href="/assets/js/100.f8328832.js"><link rel="prefetch" href="/assets/js/101.dfc5ea6f.js"><link rel="prefetch" href="/assets/js/102.fcbe44ae.js"><link rel="prefetch" href="/assets/js/103.385df0b8.js"><link rel="prefetch" href="/assets/js/104.7b0a01fc.js"><link rel="prefetch" href="/assets/js/105.526a0767.js"><link rel="prefetch" href="/assets/js/106.5d05e24e.js"><link rel="prefetch" href="/assets/js/107.cb40c7fe.js"><link rel="prefetch" href="/assets/js/108.1c1f1618.js"><link rel="prefetch" href="/assets/js/109.e1dc03c6.js"><link rel="prefetch" href="/assets/js/11.c9f038f7.js"><link rel="prefetch" href="/assets/js/110.41fd1a5d.js"><link rel="prefetch" href="/assets/js/111.3f9032f2.js"><link rel="prefetch" href="/assets/js/112.7affee06.js"><link rel="prefetch" href="/assets/js/113.11919df4.js"><link rel="prefetch" href="/assets/js/114.0d9440b9.js"><link rel="prefetch" href="/assets/js/115.55dea726.js"><link rel="prefetch" href="/assets/js/116.cef2e74b.js"><link rel="prefetch" href="/assets/js/117.13212d2c.js"><link rel="prefetch" href="/assets/js/118.a4a3d1fe.js"><link rel="prefetch" href="/assets/js/119.afcb2d7e.js"><link rel="prefetch" href="/assets/js/12.afb00e2e.js"><link rel="prefetch" href="/assets/js/120.f6d85f77.js"><link rel="prefetch" href="/assets/js/121.5dc63cd9.js"><link rel="prefetch" href="/assets/js/122.238dea33.js"><link rel="prefetch" href="/assets/js/123.10b87347.js"><link rel="prefetch" href="/assets/js/124.d450370f.js"><link rel="prefetch" href="/assets/js/125.71fbea97.js"><link rel="prefetch" href="/assets/js/126.a6962f41.js"><link rel="prefetch" href="/assets/js/127.7445f43b.js"><link rel="prefetch" href="/assets/js/128.3028bc3d.js"><link rel="prefetch" href="/assets/js/129.907a98fb.js"><link rel="prefetch" href="/assets/js/13.851aa3b0.js"><link rel="prefetch" href="/assets/js/130.a40aa055.js"><link rel="prefetch" href="/assets/js/14.1e565eeb.js"><link rel="prefetch" href="/assets/js/15.c1260bd3.js"><link rel="prefetch" href="/assets/js/16.11876a87.js"><link rel="prefetch" href="/assets/js/17.41388430.js"><link rel="prefetch" href="/assets/js/18.8f59bed3.js"><link rel="prefetch" href="/assets/js/19.f82fd3e7.js"><link rel="prefetch" href="/assets/js/20.01bc29a5.js"><link rel="prefetch" href="/assets/js/21.a6c9f65c.js"><link rel="prefetch" href="/assets/js/22.96b40d55.js"><link rel="prefetch" href="/assets/js/23.cb5eadb2.js"><link rel="prefetch" href="/assets/js/24.c3da8d07.js"><link rel="prefetch" href="/assets/js/25.58de6fc7.js"><link rel="prefetch" href="/assets/js/26.3d7b3b4c.js"><link rel="prefetch" href="/assets/js/27.47caaeb2.js"><link rel="prefetch" href="/assets/js/28.10cb7709.js"><link rel="prefetch" href="/assets/js/29.203f511c.js"><link rel="prefetch" href="/assets/js/30.1a107e29.js"><link rel="prefetch" href="/assets/js/31.2a927868.js"><link rel="prefetch" href="/assets/js/32.907cbc8a.js"><link rel="prefetch" href="/assets/js/33.a44dd8e8.js"><link rel="prefetch" href="/assets/js/34.c402c77c.js"><link rel="prefetch" href="/assets/js/35.843ae30a.js"><link rel="prefetch" href="/assets/js/36.669e6098.js"><link rel="prefetch" href="/assets/js/37.868a704e.js"><link rel="prefetch" href="/assets/js/38.2e62add7.js"><link rel="prefetch" href="/assets/js/39.f115c652.js"><link rel="prefetch" href="/assets/js/4.e842843a.js"><link rel="prefetch" href="/assets/js/40.3e7a9001.js"><link rel="prefetch" href="/assets/js/41.ff80c0b6.js"><link rel="prefetch" href="/assets/js/42.571d1c78.js"><link rel="prefetch" href="/assets/js/43.612ac1d0.js"><link rel="prefetch" href="/assets/js/44.df33b26c.js"><link rel="prefetch" href="/assets/js/45.446d1b4a.js"><link rel="prefetch" href="/assets/js/46.a27e67e9.js"><link rel="prefetch" href="/assets/js/47.50ddf426.js"><link rel="prefetch" href="/assets/js/48.c1e05fc6.js"><link rel="prefetch" href="/assets/js/49.4e215a10.js"><link rel="prefetch" href="/assets/js/5.faf24bb6.js"><link rel="prefetch" href="/assets/js/50.5750d197.js"><link rel="prefetch" href="/assets/js/51.9fd6a006.js"><link rel="prefetch" href="/assets/js/52.38e7a87f.js"><link rel="prefetch" href="/assets/js/53.53de055a.js"><link rel="prefetch" href="/assets/js/54.2bc1fbb8.js"><link rel="prefetch" href="/assets/js/55.338ff65f.js"><link rel="prefetch" href="/assets/js/56.e8b50575.js"><link rel="prefetch" href="/assets/js/57.9345fd28.js"><link rel="prefetch" href="/assets/js/58.87070755.js"><link rel="prefetch" href="/assets/js/59.ac8f294c.js"><link rel="prefetch" href="/assets/js/6.a78c385c.js"><link rel="prefetch" href="/assets/js/60.68018617.js"><link rel="prefetch" href="/assets/js/61.3282694f.js"><link rel="prefetch" href="/assets/js/62.dafafb46.js"><link rel="prefetch" href="/assets/js/63.3f3b92e2.js"><link rel="prefetch" href="/assets/js/64.4b8948a8.js"><link rel="prefetch" href="/assets/js/65.5c27ee30.js"><link rel="prefetch" href="/assets/js/66.8d9b8a0f.js"><link rel="prefetch" href="/assets/js/67.909fb64c.js"><link rel="prefetch" href="/assets/js/68.35ff6604.js"><link rel="prefetch" href="/assets/js/69.bcb625fc.js"><link rel="prefetch" href="/assets/js/7.428acef7.js"><link rel="prefetch" href="/assets/js/70.6b893791.js"><link rel="prefetch" href="/assets/js/71.0e10db4d.js"><link rel="prefetch" href="/assets/js/72.66cb408a.js"><link rel="prefetch" href="/assets/js/73.fd34099b.js"><link rel="prefetch" href="/assets/js/74.bdc550b1.js"><link rel="prefetch" href="/assets/js/75.f6cbf5b6.js"><link rel="prefetch" href="/assets/js/76.22ac78a3.js"><link rel="prefetch" href="/assets/js/77.0522cac7.js"><link rel="prefetch" href="/assets/js/78.6548bde5.js"><link rel="prefetch" href="/assets/js/79.282f42ff.js"><link rel="prefetch" href="/assets/js/8.62497525.js"><link rel="prefetch" href="/assets/js/80.ee2b8cca.js"><link rel="prefetch" href="/assets/js/81.64230905.js"><link rel="prefetch" href="/assets/js/82.97473a3c.js"><link rel="prefetch" href="/assets/js/83.169fee1d.js"><link rel="prefetch" href="/assets/js/84.aeac2f5f.js"><link rel="prefetch" href="/assets/js/85.a3068696.js"><link rel="prefetch" href="/assets/js/86.a5023dc3.js"><link rel="prefetch" href="/assets/js/87.021b8746.js"><link rel="prefetch" href="/assets/js/88.1ac6b992.js"><link rel="prefetch" href="/assets/js/89.7277a168.js"><link rel="prefetch" href="/assets/js/9.f32f43c5.js"><link rel="prefetch" href="/assets/js/90.c98fb86c.js"><link rel="prefetch" href="/assets/js/91.239c4ab7.js"><link rel="prefetch" href="/assets/js/93.8f3890ca.js"><link rel="prefetch" href="/assets/js/94.93ba4984.js"><link rel="prefetch" href="/assets/js/95.d7a226ac.js"><link rel="prefetch" href="/assets/js/96.964a7c86.js"><link rel="prefetch" href="/assets/js/97.6734d2f0.js"><link rel="prefetch" href="/assets/js/98.8c145e3f.js"><link rel="prefetch" href="/assets/js/99.8ce966be.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7ffd56ab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  原创
</a></div><div class="nav-item"><a href="/translate/" class="nav-link">
  翻译
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/lmjben/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  原创
</a></div><div class="nav-item"><a href="/translate/" class="nav-link">
  翻译
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://github.com/lmjben/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>DevOps</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/devops-microfrontend.html" class="sidebar-link">微前端自检清单</a></li><li><a href="/blog/devops-kubernetes.html" class="sidebar-link">Kubernetes 使用总结</a></li><li><a href="/blog/devops-docker.html" class="sidebar-link">Docker 使用总结</a></li><li><a href="/blog/devops-git.html" class="sidebar-link">Git 常用使用方式</a></li><li><a href="/blog/devops-dependencies.html" class="sidebar-link">Package.json 依赖管理</a></li><li><a href="/blog/devops-image.html" class="sidebar-link">合理选择图片格式</a></li><li><a href="/blog/devops-performance.html" class="sidebar-link">前端性能优化</a></li><li><a href="/blog/devops-commitlint.html" class="sidebar-link">Commitlint 使用总结</a></li><li><a href="/blog/devops-cli-diy.html" class="sidebar-link">实现一个自己的 CLI</a></li><li><a href="/blog/devops-test.html" class="sidebar-link">前端测试</a></li><li><a href="/blog/devops-webpack-entry.html" class="sidebar-link">Webpack 系列（三）整体流程分析</a></li><li><a href="/blog/devops-webpack-flow.html" class="sidebar-link">Webpack 系列（二）手写模块打包代码</a></li><li><a href="/blog/devops-webpack.html" class="sidebar-link">Webpack 系列（一）使用总结</a></li><li><a href="/blog/devops-cdfang-spider.html" class="sidebar-link">实战：手搭一个 React，Typescript，Koa，GraphQL 环境</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/library-node.html" class="sidebar-link">Node.js 使用总结</a></li><li><a href="/blog/library-react.html" class="sidebar-link">React 使用总结</a></li><li><a href="/blog/libary-react-core.html" class="sidebar-link">React 核心知识</a></li><li><a href="/blog/library-react-code-1.html" class="sidebar-link">React 源码解析（一）JSX 转换</a></li><li><a href="/blog/library-react-code-2.html" class="sidebar-link">React 源码解析（二）FiberRoot 构建</a></li><li><a href="/blog/library-react-code-3.html" class="sidebar-link">React 源码解析（三）Fiber 的调度过程</a></li><li><a href="/blog/library-react-code-4.html" class="sidebar-link">React 源码解析（四）深入理解 fiber 更新过程</a></li><li><a href="/blog/library-react-ssr.html" class="sidebar-link">React 服务器端渲染</a></li><li><a href="/blog/library-react-hooks.html" class="sidebar-link">使用 React Hooks 节省 90% 的代码</a></li><li><a href="/blog/library-vue.html" class="sidebar-link">Vue 使用总结</a></li><li><a href="/blog/library-vue-flow.html" class="sidebar-link">图解 Vue 响应式原理</a></li><li><a href="/blog/library-vue-nexttick.html" class="sidebar-link">图解 Vue 异步更新</a></li><li><a href="/blog/library-miniProgram.html" class="sidebar-link">小程序使用总结</a></li><li><a href="/blog/library-redux.html" class="sidebar-link">Redux 使用总结</a></li><li><a href="/blog/library-react-redux-code.html" class="sidebar-link">React Hooks 替代 React-Redux</a></li><li><a href="/blog/library-rxjs.html" class="sidebar-link">RxJS 基础知识总结</a></li><li><a href="/blog/library-koa.html" class="sidebar-link">Koa 源码阅读</a></li><li><a href="/blog/library-koa-diy.html" class="sidebar-link">深入 Koa 原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/css-icon.html" class="sidebar-link">网站图标开发指南</a></li><li><a href="/blog/css.html" class="sidebar-link">CSS 使用总结</a></li><li><a href="/blog/css-modules.html" class="sidebar-link">CSS 模块化</a></li><li><a href="/blog/css-next.html" class="sidebar-link">CSS NEXT 语法</a></li><li><a href="/blog/css-ifc.html" class="sidebar-link">CSS IFC 总结</a></li><li><a href="/blog/css-flex.html" class="sidebar-link">CSS Flex 布局总结</a></li><li><a href="/blog/css-useful.html" class="sidebar-link">CSS 有趣的特性</a></li><li><a href="/blog/css-devicePixelRatio.html" class="sidebar-link">CSS 设备像素比</a></li><li><a href="/blog/css-houdini-star.html" class="sidebar-link">CSS Houdini 画一片星空</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络协议</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/osi-flow.html" class="active sidebar-link">一文串联 HTTP、TCP、IP、以太网</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/osi-flow.html#建立连接阶段" class="sidebar-link">建立连接阶段</a></li><li class="sidebar-sub-header"><a href="/blog/osi-flow.html#发送数据阶段" class="sidebar-link">发送数据阶段</a></li><li class="sidebar-sub-header"><a href="/blog/osi-flow.html#思考与总结" class="sidebar-link">思考与总结</a></li></ul></li><li><a href="/blog/osi-http.html" class="sidebar-link">HTTP 协议总结</a></li><li><a href="/blog/osi-https.html" class="sidebar-link">HTTPS 协议总结</a></li><li><a href="/blog/osi-tcp.html" class="sidebar-link">TCP 协议总结</a></li><li><a href="/blog/osi-web-security.html" class="sidebar-link">一文读懂 Web 安全</a></li><li><a href="/blog/osi-web-login.html" class="sidebar-link">前端登录，这一篇就够了</a></li><li><a href="/blog/osi-hijack.html" class="sidebar-link">流量劫持</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>运维相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/operation-docker-micro-service.html" class="sidebar-link">Docker 部署简单的 Web 服务</a></li><li><a href="/blog/operation-linux.html" class="sidebar-link">Linux 快捷键</a></li><li><a href="/blog/operation-linux-login.html" class="sidebar-link">Linux 免密登录配置</a></li><li><a href="/blog/operation-linux-file.html" class="sidebar-link">Linux 替换文件内容命令</a></li><li><a href="/blog/operation-nginx-match.html" class="sidebar-link">Nginx Location 匹配规则</a></li><li><a href="/blog/operation-nginx-load-balancing.html" class="sidebar-link">Nginx 负载均衡配置</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS 基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js-prototype.html" class="sidebar-link">快速读懂 JS 原型链</a></li><li><a href="/blog/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li><li><a href="/blog/js-promise.html" class="sidebar-link">JS 理解 Promise</a></li><li><a href="/blog/js-this.html" class="sidebar-link">JS 理解 This</a></li><li><a href="/blog/js-canvas.html" class="sidebar-link">两行代码实现图片碎片化加载</a></li><li><a href="/blog/js-operator-priority.html" class="sidebar-link">JS 运算符优先级</a></li><li><a href="/blog/js-jsBridge.html" class="sidebar-link">JS Bridge 总结</a></li><li><a href="/blog/js-module.html" class="sidebar-link">JS 模块化</a></li><li><a href="/blog/js-inherit.html" class="sidebar-link">JS 实现继承</a></li><li><a href="/blog/js-event.html" class="sidebar-link">JS 事件</a></li><li><a href="/blog/js-form.html" class="sidebar-link">JS 表单基础知识</a></li><li><a href="/blog/js-html5-program.html" class="sidebar-link">JS PostMessage &amp; 拖放 API</a></li><li><a href="/blog/js-recursion.html" class="sidebar-link">JS 函数尾递归优化</a></li><li><a href="/blog/js-object-ergodic.html" class="sidebar-link">JS 对象属性的遍历</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编程基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/base-function-monad.html" class="sidebar-link">学习函数式编程 Monad</a></li><li><a href="/blog/base-function.html" class="sidebar-link">轻松实战函数式编程</a></li><li><a href="/blog/base-typescript.html" class="sidebar-link">Typescript 使用总结</a></li><li><a href="/blog/base-graphql.html" class="sidebar-link">GraphQL 使用总结</a></li><li><a href="/blog/base-ioc.html" class="sidebar-link">你需要知道的依赖注入</a></li><li><a href="/blog/base-functional.html" class="sidebar-link">函数式编程</a></li><li><a href="/blog/base-webcomponents.html" class="sidebar-link">Web Component 基础</a></li><li><a href="/blog/base-structure.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/blog/base-structure-base-select.html" class="sidebar-link">查找算法</a></li><li><a href="/blog/base-structure-base-sort.html" class="sidebar-link">基本排序算法</a></li><li><a href="/blog/base-structure-high-algorithm.html" class="sidebar-link">高级算法</a></li><li><a href="/blog/base-structure-senior-sort.html" class="sidebar-link">高级排序算法</a></li><li><a href="/blog/base-design-pattern.html" class="sidebar-link">设计模式</a></li><li><a href="/blog/base-computer.html" class="sidebar-link">计算机组成原理</a></li><li><a href="/blog/base-technology.html" class="sidebar-link">专业术语</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>总结思考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/2020-6.html" class="sidebar-link">我的 2020 总结（上）</a></li><li><a href="/blog/2019-12.html" class="sidebar-link">我的 2019 总结（下）</a></li><li><a href="/blog/2019-6.html" class="sidebar-link">我的 2019 总结（上）</a></li><li><a href="/blog/2018.html" class="sidebar-link">我的 2018 总结</a></li><li><a href="/blog/frontend.html" class="sidebar-link">我的前端知识清单</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其它</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/other-pit.html" class="sidebar-link">记录遇到的坑</a></li><li><a href="/blog/other-tools.html" class="sidebar-link">常用工具整理</a></li><li><a href="/blog/other-vscode.html" class="sidebar-link">VSCode 常用快捷键</a></li><li><a href="/blog/other-npm.html" class="sidebar-link">实用的 npm 包</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一文串联-http、tcp、ip、以太网"><a href="#一文串联-http、tcp、ip、以太网" class="header-anchor">#</a> 一文串联 HTTP、TCP、IP、以太网</h1> <p>最近部门组织了一次前端性能优化交流会，大家从输入页面 URL 到最终页面展示内容这个过程提出了许多优化点。但同时发现很多同学对 HTTP 协议层的知识不能串联起来，于是整理了这篇文章，希望可以给大家带来一丝灵感。</p> <p>当我们在页面上发起一个 AJAX 请求的时候，在网络协议层面都经历了哪些内容？</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 发起请求</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://baidu.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 协议层1...</span>
<span class="token comment">// 协议层2...</span>
<span class="token comment">// 协议层3...</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span>
  <span class="token comment">// 得到结果</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如上述代码所示，我们对 <code>baidu.com</code> 发起了一个网络请求，最终在 then 方法中得到了具体的响应内容。</p> <p>使用 Wireshark 抓包结果如下：</p> <p><img src="https://cdn.yinhengli.com/image-20201212121811481.png" alt=""></p> <p>图中可以看到，请求 baidu.com 时，首先通过 TCP 3 次握手建立连接，然后通过 HTTP 传输内容，最后通过 TCP 4 次挥手断开连接。</p> <p>真实的过程更加复杂，我们主要分析以下几点：</p> <ul><li>建立连接阶段
<ul><li>DNS 域名解析（应用层）</li> <li>建立 TCP 连接（传输层）
<ul><li>通过 IP 寻址找到目标服务器（网络层）</li> <li>通过 Mac 寻址找到服务器硬件接口（数据链路层）</li> <li>通过网线向服务器硬件接口传输比特信息（物理层）</li></ul></li></ul></li> <li>发送数据阶段
<ul><li>建立 SSL 安全连接（传输层）</li> <li>发送 HTTP 请求（应用层）</li></ul></li></ul> <h2 id="建立连接阶段"><a href="#建立连接阶段" class="header-anchor">#</a> 建立连接阶段</h2> <p>要获取 baidu.com 的网页内容，就需要和 baidu 服务器建立连接，怎样建立这个连接呢？</p> <ol><li>通过 DNS 获取 baidu 的 IP 地址。</li> <li>建立 TCP 连接。</li></ol> <h3 id="dns-域名解析"><a href="#dns-域名解析" class="header-anchor">#</a> DNS 域名解析</h3> <p>通过 DNS 解析，我们就能找到 baidu 服务器对应的 IP 地址。</p> <p>如图：</p> <p><img src="https://cdn.yinhengli.com/image-20201221212110456.png" alt=""></p> <p>经过 DNS 解析后，我们就能得到 baidu.com 的 IP 地址了：39.156.69.79 和 220.181.38.148，通常客户端会随机选中一个 IP 地址进行通信。</p> <h4 id="域名的解析步骤"><a href="#域名的解析步骤" class="header-anchor">#</a> 域名的解析步骤</h4> <p>其实 IP 不一定要通过 DNS 解析才能获取，它通常会被客户端缓存，只有在 DNS 缓存都没有命中的时候才会请求 DNS 服务器。</p> <p>判断步骤如下：</p> <ol><li>判断浏览器是否有缓存 IP 地址。</li> <li>判断本机是否有缓存该 IP 地址，如：检查 Host 文件。</li> <li>判断本地域名解析服务器是否有缓存 IP 地址，如：电信，联通等运营商。</li> <li>向 DNS 根域名解析服务器，解析域名 IP 地址。</li> <li>向 DNS 二根域名解析服务器，解析域名 IP 地址。</li> <li>以此类推，最终获得 IP 地址。</li></ol> <h3 id="建立-tcp-连接"><a href="#建立-tcp-连接" class="header-anchor">#</a> 建立 TCP 连接</h3> <p>有了 IP 地址之后，客户端和服务器端就能建立连接了，首先是建立 TCP 连接。</p> <p>TCP 是一种面向连接的、<strong>可靠的</strong>、基于<strong>字节流</strong>的传输层通信协议。</p> <p>在这一层，我们传输的数据会按照一个个的字节装入报文中，当报文的长度达到最大分段（MSS）时，就会发送这个报文。如果传输的报文很长，可能会被拆分成多个 TCP 报文进行传输。</p> <p>TCP 报文头如下：</p> <p><img src="https://cdn.yinhengli.com/image-20201221100730496.png" alt=""></p> <p>我们主要看以下几点：</p> <ul><li>源端口、目的端口。</li> <li>序列号：seq，报文的唯一标识。</li> <li>确认号：ack，报文的确认标识，便于确认 seq 是否已经收到。</li> <li>TCP 标记：
<ul><li>SYN 为 1 表示这是连接请求或是连接接受请求。用于创建连接和同步序列号。</li> <li>ACK 为 1 表示确认号字段有效。注意这里大写的 ACK 只是一个标记，和确认号 ack 并不相同。</li> <li>FIN 为 1 表示要求释放连接。</li></ul></li> <li>窗口：表示发送方可以接收的字节数，即接收窗口大小，用于流量控制。</li></ul> <p>接下来，我们看一下 TCP 是怎样建立连接的？</p> <p><img src="https://lmjben.github.io/blog/osi-tcp-connect.png" alt=""></p> <p>如图所示，建立 TCP 连接需要 3 个步骤，俗称三次握手。</p> <ul><li>第一次握手：客户端向服务器端发送序列号 seq=x 的标识，表示开始建立连接。</li> <li>第二次握手：服务器端回发一个 ack=x+1 的标识，表示确认收到第一次握手，同时发送自己的标识 seq=y。
<ul><li>客户端确认自己发出的数据能够被服务器端收到。</li></ul></li> <li>第三次握手：客户端发送 ack=y+1 的标识，标识确认收到第二次握手。
<ul><li>服务器端确认自己发出的数据能够被客户端收到。</li></ul></li></ul> <p>经过了 3 次握手，即保证了客户端和服务器端都能正常发送和接收数据，TCP 连接也就建立成功了。</p> <h4 id="tcp-可靠传输原理"><a href="#tcp-可靠传输原理" class="header-anchor">#</a> TCP 可靠传输原理</h4> <p>上文中说到，TCP 是可靠的传输，这是为什么呢？</p> <p>这是因为 TCP 内部使用了 <strong>停止等待协议 ARQ</strong> ，它通过 <strong>确认</strong> 和 <strong>重传</strong> 机制，实现了信息的可靠传输。</p> <p>例如：</p> <p><img src="https://img2018.cnblogs.com/blog/1639079/201903/1639079-20190326083658281-1497754404.png" alt=""></p> <ul><li>客户端发送数据 M1</li> <li>服务器端确认数据 M1 收到</li> <li>客户端发送数据 M2</li> <li>服务器端确认数据 M2 收到</li> <li>依次类推 ...</li></ul> <p>在这期间，如果某一条数据很久都没有得到确认，客户端就会重传这条数据。这样一来，对于与每一次发送的数据，服务器端都得到了确认，即保证了数据的可靠性。</p> <p>虽然 ARQ 可以满足数据可靠性，但每次只能发送和确认一个请求，效率太低了，于是就产生了连续 ARQ 协议。</p> <p><strong>连续 ARQ 协议</strong> 会连续发送一组数据，然后再批量等待这一组数据的确认信息，好比把单线程 ARQ 变成了多线程，大大提高了资源的利用效率。</p> <p><img src="https://cdn.yinhengli.com/WX20201226-125758@2x.png" alt=""></p> <p>如：</p> <ul><li>客户端发送数据 M1、M2、M3、M4。</li> <li>服务器端确认数据 M4 收到，表示 M4 及之前的数据都收到了。</li> <li>客户端发送数据 M5、M6、M7、M8。</li> <li>服务器端确认数据 M8 收到，表示 M8 及之前的数据都收到了。</li></ul> <p>在这个流程中，服务器端不需要对每一个数据都返回确认信息，而是接收到多个数据时一并确认，这个方式叫做 <strong>累计确认</strong>。</p> <hr> <p>这里有个疑问，TCP 的每一次握手，是怎么找到目的服务器呢？</p> <p>答：通过 IP 协议。</p> <h3 id="根据-ip-协议找到目标服务器"><a href="#根据-ip-协议找到目标服务器" class="header-anchor">#</a> 根据 IP 协议找到目标服务器</h3> <p>IP 协议的目的是实现网络层的数据转发，它通过路由器不断跳转，最终把数据成功送达目的地。</p> <p>上文中的每一次 TCP 握手以及数据交互，都是通过 IP 协议去传输的。</p> <p>IP 报文头如下：</p> <p><img src="https://strawhatfy.github.io/2015/07/30/TCP-IP-Protocol/ip_package.png" alt=""></p> <p>我们关注以下两点就可以了：</p> <ul><li>源 IP 地址</li> <li>目的 IP 地址</li></ul> <p>发起一个 IP 请求执行流程如下：</p> <ol><li>构建 IP 请求头（源 IP、目标 IP）。</li> <li>IP 协议通过算法，计算出一条通往服务器端的路径。</li> <li>发送端查询路由表，找出下一跳的 IP 地址（通常是路由器），并发送数据。</li> <li>路由器查询路由表，找出下一跳的 IP 地址，并发送数据。</li> <li>不断重复步骤 4，直到找到目的局域网。</li> <li>发送数据。</li></ol> <blockquote><p>路由表存在于计算机或路由器中，由目的 IP 地址、子网掩码、下一跳地址、发送接口四部分组成。通过目的 IP 地址，即可找到下一跳的地址，进行转发。</p></blockquote> <p>例如：A 要向 G 发送 IP 数据。</p> <p><img src="https://cdn.yinhengli.com/WX20201227-120828@2x.png" alt=""></p> <p>具体流程如下：</p> <ul><li>A 生成 IP 头部（源 IP：A ，目的 IP：G）
<ul><li>A 查询路由表，发现下一跳为 B，于是把数据传给 B。</li></ul></li> <li>B 生成 IP 头部（源 IP：A ，目的 IP：G）
<ul><li>B 查询路由表，发现下一跳为 E，于是把数据传给 E。</li></ul></li> <li>E 生成 IP 头部（源 IP：A ，目的 IP：G）
<ul><li>E 查询路由表，发现下一跳为 G，于是把数据传给 G。</li></ul></li> <li>到达目的地 G。</li></ul> <p>你是否有疑惑，为什么 IP 会按照这条路径向 G 传输数据呢？</p> <p>其实，上图中的路径并非只有一条，我们通过 ABEG 到达了目的地 G，同样也可以通过 ABCFHG 到达 G，这两种路径都能完成任务，为什么 IP 不选择 ABCFHG 这条路径呢？</p> <p>这就涉及到了 IP 寻址的算法。</p> <h4 id="ip-寻址算法"><a href="#ip-寻址算法" class="header-anchor">#</a> IP 寻址算法</h4> <p>我们可以把网络中的所有计算机都看做是一个点，计算机之间的连接看做是一条线，这些点和线就组合成了一个图。</p> <p>例如：</p> <p><img src="https://www.researchgate.net/profile/David_Brcic/publication/337784487/figure/fig10/AS:833070370418689@1575630862909/Representation-of-determined-Dijkstras-shortest-path-Dijkstra-1959.jpg" alt=""></p> <p>通过上图，我们就把复杂的网络转化成了数学问题。IP 寻址算法，其实就是图论中的最短路径的算法。</p> <p>最短路径算法在 IP 协议中有 2 种实现：</p> <ul><li>RIP 协议
<ul><li>使用距离矢量算法，<strong>确保 IP 路由跳转的次数最小</strong>。</li> <li>原理
<ul><li>每个节点中都保存有其他节点的位置信息（跳数和下一跳的 IP）。</li> <li>通过和邻居节点进行数据交换，更新自己到目的地的最短距离，不断重复，即可得到起点到终点的最短路径。</li> <li>实现简单，开销很小，适用于小型网络。</li></ul></li></ul></li> <li>OSPF 协议
<ul><li>使用迪杰斯特拉算法，<strong>确保 IP 路由跳转的速度最快</strong>。</li> <li>原理
<ul><li>从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</li> <li>适用于大型网络。</li></ul></li></ul></li></ul> <p>通过以上两个协议，我们就能找到通往目的地的路径了。</p> <hr> <p>这里抛出一个问题：IP 数据是怎样从一个路由器跳到另一个路由器呢？</p> <p>答：通过以太网协议。</p> <h3 id="通过-mac-寻址找到服务器硬件接口"><a href="#通过-mac-寻址找到服务器硬件接口" class="header-anchor">#</a> 通过 Mac 寻址找到服务器硬件接口</h3> <p>IP 协议主要是用来寻找最优路径的，具体的传输是由以太网协议来做的。</p> <p>以太网属于数据链路层，它主要负责相邻设备的通信。原理是通过查询交换机 Mac 表，找到通信双方的物理接口，进而开始通信。</p> <p>以太网报文头如下：</p> <p><img src="https://cdn.yinhengli.com/image-20201223113346648.png" alt=""></p> <p>我们只用关心以下 3 个点：</p> <ul><li>源 Mac 地址</li> <li>目的 Mac 地址</li> <li>校验码 CRC：校验当前帧是否有效。</li></ul> <p>可以看到，以太网层都是通过 Mac 地址进行通信的，这里的 Mac 地址是哪里来的呢？</p> <p>答：通过 ARP 协议。</p> <p><strong>ARP 协议</strong> 是一个通过解析 IP 地址来找寻 Mac 地址的协议。IP 地址转换成 Mac 地址后，就能进行以太网数据传输了。</p> <p>例如：</p> <p><img src="https://cdn.yinhengli.com/WX20201227-122253@2x.png" alt=""></p> <p>当机器 A 向机器 C 发送数据时：</p> <ul><li>A 构建以太网报文（源地址：A，目的地址：C），并通过网卡发出数据帧。</li> <li>数据帧到达交换机 B，交换机取出目的地址 C 的 Mac 地址。</li> <li>B 查询 Mac 表，根据目的地 Mac 地址，匹配 C 的硬件接口。
<ul><li>如果找到 C 的硬件接口，发送数据。</li> <li>如果未找到 C 的硬件接口，向 B 直连的所有机器发送广播信息找 C，找到后会把 C 记录到 Mac 表中。</li></ul></li></ul> <p>经过上述的流程，我们就找到了目的机器的硬件接口。</p> <hr> <p>通过以太网协议，我们找到了目标机器的硬件接口，接下来要怎么发送信息呢？</p> <p>答：通过物理层。</p> <h3 id="通过网线向服务器硬件接口传输比特信息"><a href="#通过网线向服务器硬件接口传输比特信息" class="header-anchor">#</a> 通过网线向服务器硬件接口传输比特信息</h3> <p>在没有 WiFi 的年代，我们只能通过插网线来进行上网，网线其实就是物理层的设备之一。</p> <p>网线可以由多种材料组成，最常见的就是光纤和电缆。</p> <p>光纤和电缆的传输原理类似，都是通过两个信号来模拟二进制数据的，一个信号即为一个比特。</p> <ul><li>电缆中：高电位表示 1 ，低点位表示 0。</li> <li>光纤中：光亮表示 1，光熄灭表示 0。</li></ul> <p>如：在光纤中，我们通过观察光的闪动，即可得知传输的二进制数据。</p> <p>有了这些物理设备，我们就能把复杂的数据转换成光信号或者电信号进行传输了。</p> <h2 id="发送数据阶段"><a href="#发送数据阶段" class="header-anchor">#</a> 发送数据阶段</h2> <p>发送数据可以分为两个步骤：</p> <ul><li>建立安全层 SSL</li> <li>发送 HTTP 请求</li></ul> <h3 id="建立安全层-ssl"><a href="#建立安全层-ssl" class="header-anchor">#</a> 建立安全层 SSL</h3> <p>本文的案例是发送一个 HTTPS 的请求，所以在发送数据之前，会创建一个 SSL 安全层，用于数据加密。</p> <p>通常的加密方法有两种：</p> <ul><li>非对称加密
<ul><li>A 有钥匙，B 没有钥匙，且他们都有一个公共的锁，B 给 A 发送数据时，都会先把数据锁起来再发送。</li> <li>接收数据时，A 用钥匙解开锁，即可得到数据。除 A 以外，其他人没有钥匙，也就获取不到数据。</li> <li>实现了单向通信加密。</li></ul></li> <li>对称加密
<ul><li>A、B 双方都有一把相同的钥匙和一个公共的锁，每次发送数据时，都把数据放在锁里进行发送。</li> <li>接收数据时，A、B 双方就用各自的钥匙来解锁。其他人没有钥匙，也就获取不到数据。</li> <li>实现了双向通信加密。</li></ul></li></ul> <p>互联网通信是双向的，所以我们需要使用对称加密，可是，怎样才能保证通信双方都有一把相同的钥匙呢？</p> <p>目前的解决方案：</p> <ul><li>先使用非对称加密，进行秘钥协商，让通信双方拿到相同的钥匙。</li> <li>然后使用对称加密，进行加密传输。</li></ul> <p>秘钥协商过程如图：</p> <p><img src="https://cdn.yinhengli.com/image-20201220213646273.png" alt=""></p> <p>图中划重点：</p> <ol><li>客户端发送自身支持的加密算法。</li> <li>服务器端选择一种加密算法，同时返回数字证书。</li> <li>客户端确认证书有效。</li> <li>客户端生成随机数，并使用证书中的服务器公钥加密，然后发送给服务器。</li> <li>服务器端使用私钥解密，获得随机数。</li> <li>双方使用第 2 步确定的加密算法，把随机数进行加密，即可获得相同的对称加密秘钥。</li></ol> <p>Ok，秘钥协商之后，我们的 SSL 安全层也就建好了。</p> <p>秘钥协商时存在一个问题：</p> <blockquote><p>秘钥协商时，怎么保证是和真正的服务器在协商，而不是一个中间人呢？</p> <p>答：<strong>数字证书</strong>。</p></blockquote> <p>数字证书重点关注 2 个部分：</p> <ul><li>服务器公钥</li> <li>数字签名</li></ul> <p>其中，数字签名又是由服务器公钥和证书私钥加密生成的，目的是为了防止服务器公钥被篡改。</p> <p><img src="https://lmjben.github.io/blog/osi-https-hash1.png" alt=""></p> <p>有了数字证书，客户端就能通过验证证书，来判断服务器是否是真正的服务器了。</p> <p>验证逻辑如下：</p> <p><img src="https://lmjben.github.io/blog/osi-https-hash2.png" alt=""></p> <p>可以看到，数字证书通过同样的算法进行解密，如果得到相同的信息摘要，就能保证数据是有效的，如果不一致，则会验证失败，拒绝后续的请求。</p> <p>到这里为止，所有的准备工作都就绪了，接下来才是发送 HTTP 请求。</p> <h3 id="发送-http-请求"><a href="#发送-http-请求" class="header-anchor">#</a> 发送 HTTP 请求</h3> <p>HTTP 协议其实就是制定了一个通信规则，规定了客户端和服务器之间的通信格式。</p> <p>以请求 baidu 首页为例：</p> <p><img src="https://cdn.yinhengli.com/iShot2020-12-24-08.36.10.png" alt=""></p> <p>如上图所示，发起 HTTP 请求时，必须遵守以下规则：</p> <ul><li>请求方法（必填） <code>GET</code></li> <li>请求地址（必填） <code>/</code></li> <li>HTTP 协议版本（必填） <code>1.1</code></li> <li>其他 HTTP 头部字段（可选） <code>Host</code>、<code>User-Agent</code>、<code>Accept</code></li> <li>请求参数，放在空行后面（可选）</li></ul> <p>服务器响应请求时，同样遵守了 HTTP 响应规则：</p> <ul><li>HTTP 协议版本（必填） <code>1.1</code></li> <li>响应状态码（必填） <code>200</code></li> <li>状态码描述（必填） <code>OK</code></li> <li>其他 HTTP 头部字段（可选） <code>Date</code>、<code>Server</code>、<code>ETag</code>、<code>Last-Modified</code> 等</li> <li>请求参数，放在空行后面（可选）</li></ul> <p>只要我们遵守这个规则，就能进行 HTTP 通信了。</p> <p>到目前为止，我们已经分析完成了数据请求的所有过程，你是否都理解了呢？</p> <h2 id="思考与总结"><a href="#思考与总结" class="header-anchor">#</a> 思考与总结</h2> <p>本文通过一个网络请求，对整个 HTTP、TCP、IP、以太网等协议进行了流程化分析，最后再梳理一下：</p> <ol><li>请求 baidu.com。</li> <li>DNS 解析 baidu.com，得到 IP 地址。</li> <li>建立 TCP 连接。</li> <li>IP 协议通过算法，计算出一条通往服务器最优路径。</li> <li>IP 沿着路径跳转时，会通过 ARP 协议把 IP 地址转换成 Mac 地址。</li> <li>以太网通过 Mac 地址，找到通信双方的硬件接口。</li> <li>物理层通过网线作为载体，在两个硬件接口之间传输比特信号。</li> <li>TCP 连接建立完毕。</li> <li>建立 SSL 安全层。</li> <li>发送 HTTP 请求。</li></ol> <p>最后，如果你对此有任何想法，欢迎留言评论！</p> <p><img src="https://cdn.yinhengli.com/qianduanrizhi_guanzhu.png" alt=""></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/lmjben/blog/edit/master/docs/blog/osi-flow.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">12/28/2020, 2:44:08 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/css-houdini-star.html" class="prev">
        CSS Houdini 画一片星空
      </a></span> <span class="next"><a href="/blog/osi-http.html">
        HTTP 协议总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.d9edef80.js" defer></script><script src="/assets/js/2.735dd80d.js" defer></script><script src="/assets/js/92.65987233.js" defer></script><script src="/assets/js/3.782c6b4d.js" defer></script>
  </body>
</html>
